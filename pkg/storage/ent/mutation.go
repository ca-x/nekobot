// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"nekobot/pkg/storage/ent/attachtoken"
	"nekobot/pkg/storage/ent/configsection"
	"nekobot/pkg/storage/ent/cronjob"
	"nekobot/pkg/storage/ent/predicate"
	"nekobot/pkg/storage/ent/provider"
	"nekobot/pkg/storage/ent/toolevent"
	"nekobot/pkg/storage/ent/toolsession"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachToken   = "AttachToken"
	TypeConfigSection = "ConfigSection"
	TypeCronJob       = "CronJob"
	TypeProvider      = "Provider"
	TypeToolEvent     = "ToolEvent"
	TypeToolSession   = "ToolSession"
)

// AttachTokenMutation represents an operation that mutates the AttachToken nodes in the graph.
type AttachTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	token         *string
	session_id    *string
	owner         *string
	expires_at    *time.Time
	used_at       *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AttachToken, error)
	predicates    []predicate.AttachToken
}

var _ ent.Mutation = (*AttachTokenMutation)(nil)

// attachtokenOption allows management of the mutation configuration using functional options.
type attachtokenOption func(*AttachTokenMutation)

// newAttachTokenMutation creates new mutation for the AttachToken entity.
func newAttachTokenMutation(c config, op Op, opts ...attachtokenOption) *AttachTokenMutation {
	m := &AttachTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachTokenID sets the ID field of the mutation.
func withAttachTokenID(id string) attachtokenOption {
	return func(m *AttachTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AttachToken
		)
		m.oldValue = func(ctx context.Context) (*AttachToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttachToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachToken sets the old AttachToken of the mutation.
func withAttachToken(node *AttachToken) attachtokenOption {
	return func(m *AttachTokenMutation) {
		m.oldValue = func(context.Context) (*AttachToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AttachToken entities.
func (m *AttachTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttachToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *AttachTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AttachTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AttachTokenMutation) ResetToken() {
	m.token = nil
}

// SetSessionID sets the "session_id" field.
func (m *AttachTokenMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *AttachTokenMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *AttachTokenMutation) ResetSessionID() {
	m.session_id = nil
}

// SetOwner sets the "owner" field.
func (m *AttachTokenMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *AttachTokenMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *AttachTokenMutation) ResetOwner() {
	m.owner = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AttachTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AttachTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AttachTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *AttachTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *AttachTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *AttachTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[attachtoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *AttachTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[attachtoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *AttachTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, attachtoken.FieldUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AttachTokenMutation builder.
func (m *AttachTokenMutation) Where(ps ...predicate.AttachToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttachToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttachToken).
func (m *AttachTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.token != nil {
		fields = append(fields, attachtoken.FieldToken)
	}
	if m.session_id != nil {
		fields = append(fields, attachtoken.FieldSessionID)
	}
	if m.owner != nil {
		fields = append(fields, attachtoken.FieldOwner)
	}
	if m.expires_at != nil {
		fields = append(fields, attachtoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, attachtoken.FieldUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, attachtoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachtoken.FieldToken:
		return m.Token()
	case attachtoken.FieldSessionID:
		return m.SessionID()
	case attachtoken.FieldOwner:
		return m.Owner()
	case attachtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case attachtoken.FieldUsedAt:
		return m.UsedAt()
	case attachtoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachtoken.FieldToken:
		return m.OldToken(ctx)
	case attachtoken.FieldSessionID:
		return m.OldSessionID(ctx)
	case attachtoken.FieldOwner:
		return m.OldOwner(ctx)
	case attachtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case attachtoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case attachtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AttachToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachtoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case attachtoken.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case attachtoken.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case attachtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case attachtoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case attachtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AttachToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AttachToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachtoken.FieldUsedAt) {
		fields = append(fields, attachtoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachTokenMutation) ClearField(name string) error {
	switch name {
	case attachtoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown AttachToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachTokenMutation) ResetField(name string) error {
	switch name {
	case attachtoken.FieldToken:
		m.ResetToken()
		return nil
	case attachtoken.FieldSessionID:
		m.ResetSessionID()
		return nil
	case attachtoken.FieldOwner:
		m.ResetOwner()
		return nil
	case attachtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case attachtoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case attachtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AttachToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AttachToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AttachToken edge %s", name)
}

// ConfigSectionMutation represents an operation that mutates the ConfigSection nodes in the graph.
type ConfigSectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	section       *string
	payload_json  *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ConfigSection, error)
	predicates    []predicate.ConfigSection
}

var _ ent.Mutation = (*ConfigSectionMutation)(nil)

// configsectionOption allows management of the mutation configuration using functional options.
type configsectionOption func(*ConfigSectionMutation)

// newConfigSectionMutation creates new mutation for the ConfigSection entity.
func newConfigSectionMutation(c config, op Op, opts ...configsectionOption) *ConfigSectionMutation {
	m := &ConfigSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigSectionID sets the ID field of the mutation.
func withConfigSectionID(id int) configsectionOption {
	return func(m *ConfigSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigSection
		)
		m.oldValue = func(ctx context.Context) (*ConfigSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigSection sets the old ConfigSection of the mutation.
func withConfigSection(node *ConfigSection) configsectionOption {
	return func(m *ConfigSectionMutation) {
		m.oldValue = func(context.Context) (*ConfigSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigSectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSection sets the "section" field.
func (m *ConfigSectionMutation) SetSection(s string) {
	m.section = &s
}

// Section returns the value of the "section" field in the mutation.
func (m *ConfigSectionMutation) Section() (r string, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSection returns the old "section" field's value of the ConfigSection entity.
// If the ConfigSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSectionMutation) OldSection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSection: %w", err)
	}
	return oldValue.Section, nil
}

// ResetSection resets all changes to the "section" field.
func (m *ConfigSectionMutation) ResetSection() {
	m.section = nil
}

// SetPayloadJSON sets the "payload_json" field.
func (m *ConfigSectionMutation) SetPayloadJSON(s string) {
	m.payload_json = &s
}

// PayloadJSON returns the value of the "payload_json" field in the mutation.
func (m *ConfigSectionMutation) PayloadJSON() (r string, exists bool) {
	v := m.payload_json
	if v == nil {
		return
	}
	return *v, true
}

// OldPayloadJSON returns the old "payload_json" field's value of the ConfigSection entity.
// If the ConfigSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSectionMutation) OldPayloadJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayloadJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayloadJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayloadJSON: %w", err)
	}
	return oldValue.PayloadJSON, nil
}

// ResetPayloadJSON resets all changes to the "payload_json" field.
func (m *ConfigSectionMutation) ResetPayloadJSON() {
	m.payload_json = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigSection entity.
// If the ConfigSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigSectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConfigSection entity.
// If the ConfigSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigSectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ConfigSectionMutation builder.
func (m *ConfigSectionMutation) Where(ps ...predicate.ConfigSection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigSectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigSectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConfigSection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigSectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigSectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConfigSection).
func (m *ConfigSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigSectionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.section != nil {
		fields = append(fields, configsection.FieldSection)
	}
	if m.payload_json != nil {
		fields = append(fields, configsection.FieldPayloadJSON)
	}
	if m.created_at != nil {
		fields = append(fields, configsection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, configsection.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configsection.FieldSection:
		return m.Section()
	case configsection.FieldPayloadJSON:
		return m.PayloadJSON()
	case configsection.FieldCreatedAt:
		return m.CreatedAt()
	case configsection.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configsection.FieldSection:
		return m.OldSection(ctx)
	case configsection.FieldPayloadJSON:
		return m.OldPayloadJSON(ctx)
	case configsection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configsection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configsection.FieldSection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSection(v)
		return nil
	case configsection.FieldPayloadJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayloadJSON(v)
		return nil
	case configsection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configsection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConfigSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigSectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigSectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConfigSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigSectionMutation) ResetField(name string) error {
	switch name {
	case configsection.FieldSection:
		m.ResetSection()
		return nil
	case configsection.FieldPayloadJSON:
		m.ResetPayloadJSON()
		return nil
	case configsection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configsection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigSectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigSectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigSectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigSectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigSectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigSection edge %s", name)
}

// CronJobMutation represents an operation that mutates the CronJob nodes in the graph.
type CronJobMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	schedule_kind    *string
	schedule         *string
	at_time          *time.Time
	every_duration   *string
	prompt           *string
	enabled          *bool
	delete_after_run *bool
	created_at       *time.Time
	last_run         *time.Time
	next_run         *time.Time
	run_count        *int
	addrun_count     *int
	last_error       *string
	last_success     *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CronJob, error)
	predicates       []predicate.CronJob
}

var _ ent.Mutation = (*CronJobMutation)(nil)

// cronjobOption allows management of the mutation configuration using functional options.
type cronjobOption func(*CronJobMutation)

// newCronJobMutation creates new mutation for the CronJob entity.
func newCronJobMutation(c config, op Op, opts ...cronjobOption) *CronJobMutation {
	m := &CronJobMutation{
		config:        c,
		op:            op,
		typ:           TypeCronJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCronJobID sets the ID field of the mutation.
func withCronJobID(id string) cronjobOption {
	return func(m *CronJobMutation) {
		var (
			err   error
			once  sync.Once
			value *CronJob
		)
		m.oldValue = func(ctx context.Context) (*CronJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CronJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCronJob sets the old CronJob of the mutation.
func withCronJob(node *CronJob) cronjobOption {
	return func(m *CronJobMutation) {
		m.oldValue = func(context.Context) (*CronJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CronJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CronJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CronJob entities.
func (m *CronJobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CronJobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CronJobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CronJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CronJobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CronJobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CronJobMutation) ResetName() {
	m.name = nil
}

// SetScheduleKind sets the "schedule_kind" field.
func (m *CronJobMutation) SetScheduleKind(s string) {
	m.schedule_kind = &s
}

// ScheduleKind returns the value of the "schedule_kind" field in the mutation.
func (m *CronJobMutation) ScheduleKind() (r string, exists bool) {
	v := m.schedule_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleKind returns the old "schedule_kind" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldScheduleKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleKind: %w", err)
	}
	return oldValue.ScheduleKind, nil
}

// ResetScheduleKind resets all changes to the "schedule_kind" field.
func (m *CronJobMutation) ResetScheduleKind() {
	m.schedule_kind = nil
}

// SetSchedule sets the "schedule" field.
func (m *CronJobMutation) SetSchedule(s string) {
	m.schedule = &s
}

// Schedule returns the value of the "schedule" field in the mutation.
func (m *CronJobMutation) Schedule() (r string, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedule returns the old "schedule" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldSchedule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedule: %w", err)
	}
	return oldValue.Schedule, nil
}

// ResetSchedule resets all changes to the "schedule" field.
func (m *CronJobMutation) ResetSchedule() {
	m.schedule = nil
}

// SetAtTime sets the "at_time" field.
func (m *CronJobMutation) SetAtTime(t time.Time) {
	m.at_time = &t
}

// AtTime returns the value of the "at_time" field in the mutation.
func (m *CronJobMutation) AtTime() (r time.Time, exists bool) {
	v := m.at_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAtTime returns the old "at_time" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldAtTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAtTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAtTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAtTime: %w", err)
	}
	return oldValue.AtTime, nil
}

// ClearAtTime clears the value of the "at_time" field.
func (m *CronJobMutation) ClearAtTime() {
	m.at_time = nil
	m.clearedFields[cronjob.FieldAtTime] = struct{}{}
}

// AtTimeCleared returns if the "at_time" field was cleared in this mutation.
func (m *CronJobMutation) AtTimeCleared() bool {
	_, ok := m.clearedFields[cronjob.FieldAtTime]
	return ok
}

// ResetAtTime resets all changes to the "at_time" field.
func (m *CronJobMutation) ResetAtTime() {
	m.at_time = nil
	delete(m.clearedFields, cronjob.FieldAtTime)
}

// SetEveryDuration sets the "every_duration" field.
func (m *CronJobMutation) SetEveryDuration(s string) {
	m.every_duration = &s
}

// EveryDuration returns the value of the "every_duration" field in the mutation.
func (m *CronJobMutation) EveryDuration() (r string, exists bool) {
	v := m.every_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldEveryDuration returns the old "every_duration" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldEveryDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEveryDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEveryDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEveryDuration: %w", err)
	}
	return oldValue.EveryDuration, nil
}

// ResetEveryDuration resets all changes to the "every_duration" field.
func (m *CronJobMutation) ResetEveryDuration() {
	m.every_duration = nil
}

// SetPrompt sets the "prompt" field.
func (m *CronJobMutation) SetPrompt(s string) {
	m.prompt = &s
}

// Prompt returns the value of the "prompt" field in the mutation.
func (m *CronJobMutation) Prompt() (r string, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPrompt returns the old "prompt" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldPrompt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrompt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrompt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrompt: %w", err)
	}
	return oldValue.Prompt, nil
}

// ResetPrompt resets all changes to the "prompt" field.
func (m *CronJobMutation) ResetPrompt() {
	m.prompt = nil
}

// SetEnabled sets the "enabled" field.
func (m *CronJobMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *CronJobMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *CronJobMutation) ResetEnabled() {
	m.enabled = nil
}

// SetDeleteAfterRun sets the "delete_after_run" field.
func (m *CronJobMutation) SetDeleteAfterRun(b bool) {
	m.delete_after_run = &b
}

// DeleteAfterRun returns the value of the "delete_after_run" field in the mutation.
func (m *CronJobMutation) DeleteAfterRun() (r bool, exists bool) {
	v := m.delete_after_run
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAfterRun returns the old "delete_after_run" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldDeleteAfterRun(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAfterRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAfterRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAfterRun: %w", err)
	}
	return oldValue.DeleteAfterRun, nil
}

// ResetDeleteAfterRun resets all changes to the "delete_after_run" field.
func (m *CronJobMutation) ResetDeleteAfterRun() {
	m.delete_after_run = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CronJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CronJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CronJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastRun sets the "last_run" field.
func (m *CronJobMutation) SetLastRun(t time.Time) {
	m.last_run = &t
}

// LastRun returns the value of the "last_run" field in the mutation.
func (m *CronJobMutation) LastRun() (r time.Time, exists bool) {
	v := m.last_run
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRun returns the old "last_run" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldLastRun(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRun: %w", err)
	}
	return oldValue.LastRun, nil
}

// ClearLastRun clears the value of the "last_run" field.
func (m *CronJobMutation) ClearLastRun() {
	m.last_run = nil
	m.clearedFields[cronjob.FieldLastRun] = struct{}{}
}

// LastRunCleared returns if the "last_run" field was cleared in this mutation.
func (m *CronJobMutation) LastRunCleared() bool {
	_, ok := m.clearedFields[cronjob.FieldLastRun]
	return ok
}

// ResetLastRun resets all changes to the "last_run" field.
func (m *CronJobMutation) ResetLastRun() {
	m.last_run = nil
	delete(m.clearedFields, cronjob.FieldLastRun)
}

// SetNextRun sets the "next_run" field.
func (m *CronJobMutation) SetNextRun(t time.Time) {
	m.next_run = &t
}

// NextRun returns the value of the "next_run" field in the mutation.
func (m *CronJobMutation) NextRun() (r time.Time, exists bool) {
	v := m.next_run
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRun returns the old "next_run" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldNextRun(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRun: %w", err)
	}
	return oldValue.NextRun, nil
}

// ClearNextRun clears the value of the "next_run" field.
func (m *CronJobMutation) ClearNextRun() {
	m.next_run = nil
	m.clearedFields[cronjob.FieldNextRun] = struct{}{}
}

// NextRunCleared returns if the "next_run" field was cleared in this mutation.
func (m *CronJobMutation) NextRunCleared() bool {
	_, ok := m.clearedFields[cronjob.FieldNextRun]
	return ok
}

// ResetNextRun resets all changes to the "next_run" field.
func (m *CronJobMutation) ResetNextRun() {
	m.next_run = nil
	delete(m.clearedFields, cronjob.FieldNextRun)
}

// SetRunCount sets the "run_count" field.
func (m *CronJobMutation) SetRunCount(i int) {
	m.run_count = &i
	m.addrun_count = nil
}

// RunCount returns the value of the "run_count" field in the mutation.
func (m *CronJobMutation) RunCount() (r int, exists bool) {
	v := m.run_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRunCount returns the old "run_count" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldRunCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunCount: %w", err)
	}
	return oldValue.RunCount, nil
}

// AddRunCount adds i to the "run_count" field.
func (m *CronJobMutation) AddRunCount(i int) {
	if m.addrun_count != nil {
		*m.addrun_count += i
	} else {
		m.addrun_count = &i
	}
}

// AddedRunCount returns the value that was added to the "run_count" field in this mutation.
func (m *CronJobMutation) AddedRunCount() (r int, exists bool) {
	v := m.addrun_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunCount resets all changes to the "run_count" field.
func (m *CronJobMutation) ResetRunCount() {
	m.run_count = nil
	m.addrun_count = nil
}

// SetLastError sets the "last_error" field.
func (m *CronJobMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *CronJobMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ResetLastError resets all changes to the "last_error" field.
func (m *CronJobMutation) ResetLastError() {
	m.last_error = nil
}

// SetLastSuccess sets the "last_success" field.
func (m *CronJobMutation) SetLastSuccess(b bool) {
	m.last_success = &b
}

// LastSuccess returns the value of the "last_success" field in the mutation.
func (m *CronJobMutation) LastSuccess() (r bool, exists bool) {
	v := m.last_success
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSuccess returns the old "last_success" field's value of the CronJob entity.
// If the CronJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronJobMutation) OldLastSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSuccess: %w", err)
	}
	return oldValue.LastSuccess, nil
}

// ResetLastSuccess resets all changes to the "last_success" field.
func (m *CronJobMutation) ResetLastSuccess() {
	m.last_success = nil
}

// Where appends a list predicates to the CronJobMutation builder.
func (m *CronJobMutation) Where(ps ...predicate.CronJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CronJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CronJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CronJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CronJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CronJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CronJob).
func (m *CronJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CronJobMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, cronjob.FieldName)
	}
	if m.schedule_kind != nil {
		fields = append(fields, cronjob.FieldScheduleKind)
	}
	if m.schedule != nil {
		fields = append(fields, cronjob.FieldSchedule)
	}
	if m.at_time != nil {
		fields = append(fields, cronjob.FieldAtTime)
	}
	if m.every_duration != nil {
		fields = append(fields, cronjob.FieldEveryDuration)
	}
	if m.prompt != nil {
		fields = append(fields, cronjob.FieldPrompt)
	}
	if m.enabled != nil {
		fields = append(fields, cronjob.FieldEnabled)
	}
	if m.delete_after_run != nil {
		fields = append(fields, cronjob.FieldDeleteAfterRun)
	}
	if m.created_at != nil {
		fields = append(fields, cronjob.FieldCreatedAt)
	}
	if m.last_run != nil {
		fields = append(fields, cronjob.FieldLastRun)
	}
	if m.next_run != nil {
		fields = append(fields, cronjob.FieldNextRun)
	}
	if m.run_count != nil {
		fields = append(fields, cronjob.FieldRunCount)
	}
	if m.last_error != nil {
		fields = append(fields, cronjob.FieldLastError)
	}
	if m.last_success != nil {
		fields = append(fields, cronjob.FieldLastSuccess)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CronJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cronjob.FieldName:
		return m.Name()
	case cronjob.FieldScheduleKind:
		return m.ScheduleKind()
	case cronjob.FieldSchedule:
		return m.Schedule()
	case cronjob.FieldAtTime:
		return m.AtTime()
	case cronjob.FieldEveryDuration:
		return m.EveryDuration()
	case cronjob.FieldPrompt:
		return m.Prompt()
	case cronjob.FieldEnabled:
		return m.Enabled()
	case cronjob.FieldDeleteAfterRun:
		return m.DeleteAfterRun()
	case cronjob.FieldCreatedAt:
		return m.CreatedAt()
	case cronjob.FieldLastRun:
		return m.LastRun()
	case cronjob.FieldNextRun:
		return m.NextRun()
	case cronjob.FieldRunCount:
		return m.RunCount()
	case cronjob.FieldLastError:
		return m.LastError()
	case cronjob.FieldLastSuccess:
		return m.LastSuccess()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CronJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cronjob.FieldName:
		return m.OldName(ctx)
	case cronjob.FieldScheduleKind:
		return m.OldScheduleKind(ctx)
	case cronjob.FieldSchedule:
		return m.OldSchedule(ctx)
	case cronjob.FieldAtTime:
		return m.OldAtTime(ctx)
	case cronjob.FieldEveryDuration:
		return m.OldEveryDuration(ctx)
	case cronjob.FieldPrompt:
		return m.OldPrompt(ctx)
	case cronjob.FieldEnabled:
		return m.OldEnabled(ctx)
	case cronjob.FieldDeleteAfterRun:
		return m.OldDeleteAfterRun(ctx)
	case cronjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cronjob.FieldLastRun:
		return m.OldLastRun(ctx)
	case cronjob.FieldNextRun:
		return m.OldNextRun(ctx)
	case cronjob.FieldRunCount:
		return m.OldRunCount(ctx)
	case cronjob.FieldLastError:
		return m.OldLastError(ctx)
	case cronjob.FieldLastSuccess:
		return m.OldLastSuccess(ctx)
	}
	return nil, fmt.Errorf("unknown CronJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CronJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cronjob.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cronjob.FieldScheduleKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleKind(v)
		return nil
	case cronjob.FieldSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedule(v)
		return nil
	case cronjob.FieldAtTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAtTime(v)
		return nil
	case cronjob.FieldEveryDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEveryDuration(v)
		return nil
	case cronjob.FieldPrompt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrompt(v)
		return nil
	case cronjob.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case cronjob.FieldDeleteAfterRun:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAfterRun(v)
		return nil
	case cronjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cronjob.FieldLastRun:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRun(v)
		return nil
	case cronjob.FieldNextRun:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRun(v)
		return nil
	case cronjob.FieldRunCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunCount(v)
		return nil
	case cronjob.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case cronjob.FieldLastSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSuccess(v)
		return nil
	}
	return fmt.Errorf("unknown CronJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CronJobMutation) AddedFields() []string {
	var fields []string
	if m.addrun_count != nil {
		fields = append(fields, cronjob.FieldRunCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CronJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cronjob.FieldRunCount:
		return m.AddedRunCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CronJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cronjob.FieldRunCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunCount(v)
		return nil
	}
	return fmt.Errorf("unknown CronJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CronJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cronjob.FieldAtTime) {
		fields = append(fields, cronjob.FieldAtTime)
	}
	if m.FieldCleared(cronjob.FieldLastRun) {
		fields = append(fields, cronjob.FieldLastRun)
	}
	if m.FieldCleared(cronjob.FieldNextRun) {
		fields = append(fields, cronjob.FieldNextRun)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CronJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CronJobMutation) ClearField(name string) error {
	switch name {
	case cronjob.FieldAtTime:
		m.ClearAtTime()
		return nil
	case cronjob.FieldLastRun:
		m.ClearLastRun()
		return nil
	case cronjob.FieldNextRun:
		m.ClearNextRun()
		return nil
	}
	return fmt.Errorf("unknown CronJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CronJobMutation) ResetField(name string) error {
	switch name {
	case cronjob.FieldName:
		m.ResetName()
		return nil
	case cronjob.FieldScheduleKind:
		m.ResetScheduleKind()
		return nil
	case cronjob.FieldSchedule:
		m.ResetSchedule()
		return nil
	case cronjob.FieldAtTime:
		m.ResetAtTime()
		return nil
	case cronjob.FieldEveryDuration:
		m.ResetEveryDuration()
		return nil
	case cronjob.FieldPrompt:
		m.ResetPrompt()
		return nil
	case cronjob.FieldEnabled:
		m.ResetEnabled()
		return nil
	case cronjob.FieldDeleteAfterRun:
		m.ResetDeleteAfterRun()
		return nil
	case cronjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cronjob.FieldLastRun:
		m.ResetLastRun()
		return nil
	case cronjob.FieldNextRun:
		m.ResetNextRun()
		return nil
	case cronjob.FieldRunCount:
		m.ResetRunCount()
		return nil
	case cronjob.FieldLastError:
		m.ResetLastError()
		return nil
	case cronjob.FieldLastSuccess:
		m.ResetLastSuccess()
		return nil
	}
	return fmt.Errorf("unknown CronJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CronJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CronJobMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CronJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CronJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CronJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CronJobMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CronJobMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CronJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CronJobMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CronJob edge %s", name)
}

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	provider_kind *string
	api_key       *string
	api_base      *string
	proxy         *string
	models_json   *string
	default_model *string
	timeout       *int
	addtimeout    *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Provider, error)
	predicates    []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id string) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Provider entities.
func (m *ProviderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProviderMutation) ResetName() {
	m.name = nil
}

// SetProviderKind sets the "provider_kind" field.
func (m *ProviderMutation) SetProviderKind(s string) {
	m.provider_kind = &s
}

// ProviderKind returns the value of the "provider_kind" field in the mutation.
func (m *ProviderMutation) ProviderKind() (r string, exists bool) {
	v := m.provider_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderKind returns the old "provider_kind" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldProviderKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderKind: %w", err)
	}
	return oldValue.ProviderKind, nil
}

// ResetProviderKind resets all changes to the "provider_kind" field.
func (m *ProviderMutation) ResetProviderKind() {
	m.provider_kind = nil
}

// SetAPIKey sets the "api_key" field.
func (m *ProviderMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *ProviderMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *ProviderMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetAPIBase sets the "api_base" field.
func (m *ProviderMutation) SetAPIBase(s string) {
	m.api_base = &s
}

// APIBase returns the value of the "api_base" field in the mutation.
func (m *ProviderMutation) APIBase() (r string, exists bool) {
	v := m.api_base
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIBase returns the old "api_base" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldAPIBase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIBase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIBase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIBase: %w", err)
	}
	return oldValue.APIBase, nil
}

// ResetAPIBase resets all changes to the "api_base" field.
func (m *ProviderMutation) ResetAPIBase() {
	m.api_base = nil
}

// SetProxy sets the "proxy" field.
func (m *ProviderMutation) SetProxy(s string) {
	m.proxy = &s
}

// Proxy returns the value of the "proxy" field in the mutation.
func (m *ProviderMutation) Proxy() (r string, exists bool) {
	v := m.proxy
	if v == nil {
		return
	}
	return *v, true
}

// OldProxy returns the old "proxy" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldProxy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProxy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProxy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProxy: %w", err)
	}
	return oldValue.Proxy, nil
}

// ResetProxy resets all changes to the "proxy" field.
func (m *ProviderMutation) ResetProxy() {
	m.proxy = nil
}

// SetModelsJSON sets the "models_json" field.
func (m *ProviderMutation) SetModelsJSON(s string) {
	m.models_json = &s
}

// ModelsJSON returns the value of the "models_json" field in the mutation.
func (m *ProviderMutation) ModelsJSON() (r string, exists bool) {
	v := m.models_json
	if v == nil {
		return
	}
	return *v, true
}

// OldModelsJSON returns the old "models_json" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldModelsJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelsJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelsJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelsJSON: %w", err)
	}
	return oldValue.ModelsJSON, nil
}

// ResetModelsJSON resets all changes to the "models_json" field.
func (m *ProviderMutation) ResetModelsJSON() {
	m.models_json = nil
}

// SetDefaultModel sets the "default_model" field.
func (m *ProviderMutation) SetDefaultModel(s string) {
	m.default_model = &s
}

// DefaultModel returns the value of the "default_model" field in the mutation.
func (m *ProviderMutation) DefaultModel() (r string, exists bool) {
	v := m.default_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultModel returns the old "default_model" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldDefaultModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultModel: %w", err)
	}
	return oldValue.DefaultModel, nil
}

// ResetDefaultModel resets all changes to the "default_model" field.
func (m *ProviderMutation) ResetDefaultModel() {
	m.default_model = nil
}

// SetTimeout sets the "timeout" field.
func (m *ProviderMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ProviderMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ProviderMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ProviderMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ProviderMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Provider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, provider.FieldName)
	}
	if m.provider_kind != nil {
		fields = append(fields, provider.FieldProviderKind)
	}
	if m.api_key != nil {
		fields = append(fields, provider.FieldAPIKey)
	}
	if m.api_base != nil {
		fields = append(fields, provider.FieldAPIBase)
	}
	if m.proxy != nil {
		fields = append(fields, provider.FieldProxy)
	}
	if m.models_json != nil {
		fields = append(fields, provider.FieldModelsJSON)
	}
	if m.default_model != nil {
		fields = append(fields, provider.FieldDefaultModel)
	}
	if m.timeout != nil {
		fields = append(fields, provider.FieldTimeout)
	}
	if m.created_at != nil {
		fields = append(fields, provider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, provider.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldName:
		return m.Name()
	case provider.FieldProviderKind:
		return m.ProviderKind()
	case provider.FieldAPIKey:
		return m.APIKey()
	case provider.FieldAPIBase:
		return m.APIBase()
	case provider.FieldProxy:
		return m.Proxy()
	case provider.FieldModelsJSON:
		return m.ModelsJSON()
	case provider.FieldDefaultModel:
		return m.DefaultModel()
	case provider.FieldTimeout:
		return m.Timeout()
	case provider.FieldCreatedAt:
		return m.CreatedAt()
	case provider.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldName:
		return m.OldName(ctx)
	case provider.FieldProviderKind:
		return m.OldProviderKind(ctx)
	case provider.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case provider.FieldAPIBase:
		return m.OldAPIBase(ctx)
	case provider.FieldProxy:
		return m.OldProxy(ctx)
	case provider.FieldModelsJSON:
		return m.OldModelsJSON(ctx)
	case provider.FieldDefaultModel:
		return m.OldDefaultModel(ctx)
	case provider.FieldTimeout:
		return m.OldTimeout(ctx)
	case provider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case provider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provider.FieldProviderKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderKind(v)
		return nil
	case provider.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case provider.FieldAPIBase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIBase(v)
		return nil
	case provider.FieldProxy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProxy(v)
		return nil
	case provider.FieldModelsJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelsJSON(v)
		return nil
	case provider.FieldDefaultModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultModel(v)
		return nil
	case provider.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case provider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case provider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, provider.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case provider.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldName:
		m.ResetName()
		return nil
	case provider.FieldProviderKind:
		m.ResetProviderKind()
		return nil
	case provider.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case provider.FieldAPIBase:
		m.ResetAPIBase()
		return nil
	case provider.FieldProxy:
		m.ResetProxy()
		return nil
	case provider.FieldModelsJSON:
		m.ResetModelsJSON()
		return nil
	case provider.FieldDefaultModel:
		m.ResetDefaultModel()
		return nil
	case provider.FieldTimeout:
		m.ResetTimeout()
		return nil
	case provider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case provider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Provider edge %s", name)
}

// ToolEventMutation represents an operation that mutates the ToolEvent nodes in the graph.
type ToolEventMutation struct {
	config
	op            Op
	typ           string
	id            *string
	session_id    *string
	event_type    *string
	payload_json  *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ToolEvent, error)
	predicates    []predicate.ToolEvent
}

var _ ent.Mutation = (*ToolEventMutation)(nil)

// tooleventOption allows management of the mutation configuration using functional options.
type tooleventOption func(*ToolEventMutation)

// newToolEventMutation creates new mutation for the ToolEvent entity.
func newToolEventMutation(c config, op Op, opts ...tooleventOption) *ToolEventMutation {
	m := &ToolEventMutation{
		config:        c,
		op:            op,
		typ:           TypeToolEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolEventID sets the ID field of the mutation.
func withToolEventID(id string) tooleventOption {
	return func(m *ToolEventMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolEvent
		)
		m.oldValue = func(ctx context.Context) (*ToolEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolEvent sets the old ToolEvent of the mutation.
func withToolEvent(node *ToolEvent) tooleventOption {
	return func(m *ToolEventMutation) {
		m.oldValue = func(context.Context) (*ToolEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ToolEvent entities.
func (m *ToolEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *ToolEventMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *ToolEventMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *ToolEventMutation) ResetSessionID() {
	m.session_id = nil
}

// SetEventType sets the "event_type" field.
func (m *ToolEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ToolEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ToolEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetPayloadJSON sets the "payload_json" field.
func (m *ToolEventMutation) SetPayloadJSON(s string) {
	m.payload_json = &s
}

// PayloadJSON returns the value of the "payload_json" field in the mutation.
func (m *ToolEventMutation) PayloadJSON() (r string, exists bool) {
	v := m.payload_json
	if v == nil {
		return
	}
	return *v, true
}

// OldPayloadJSON returns the old "payload_json" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldPayloadJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayloadJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayloadJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayloadJSON: %w", err)
	}
	return oldValue.PayloadJSON, nil
}

// ClearPayloadJSON clears the value of the "payload_json" field.
func (m *ToolEventMutation) ClearPayloadJSON() {
	m.payload_json = nil
	m.clearedFields[toolevent.FieldPayloadJSON] = struct{}{}
}

// PayloadJSONCleared returns if the "payload_json" field was cleared in this mutation.
func (m *ToolEventMutation) PayloadJSONCleared() bool {
	_, ok := m.clearedFields[toolevent.FieldPayloadJSON]
	return ok
}

// ResetPayloadJSON resets all changes to the "payload_json" field.
func (m *ToolEventMutation) ResetPayloadJSON() {
	m.payload_json = nil
	delete(m.clearedFields, toolevent.FieldPayloadJSON)
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ToolEventMutation builder.
func (m *ToolEventMutation) Where(ps ...predicate.ToolEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolEvent).
func (m *ToolEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolEventMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.session_id != nil {
		fields = append(fields, toolevent.FieldSessionID)
	}
	if m.event_type != nil {
		fields = append(fields, toolevent.FieldEventType)
	}
	if m.payload_json != nil {
		fields = append(fields, toolevent.FieldPayloadJSON)
	}
	if m.created_at != nil {
		fields = append(fields, toolevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolevent.FieldSessionID:
		return m.SessionID()
	case toolevent.FieldEventType:
		return m.EventType()
	case toolevent.FieldPayloadJSON:
		return m.PayloadJSON()
	case toolevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolevent.FieldSessionID:
		return m.OldSessionID(ctx)
	case toolevent.FieldEventType:
		return m.OldEventType(ctx)
	case toolevent.FieldPayloadJSON:
		return m.OldPayloadJSON(ctx)
	case toolevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ToolEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolevent.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case toolevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case toolevent.FieldPayloadJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayloadJSON(v)
		return nil
	case toolevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ToolEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ToolEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolevent.FieldPayloadJSON) {
		fields = append(fields, toolevent.FieldPayloadJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolEventMutation) ClearField(name string) error {
	switch name {
	case toolevent.FieldPayloadJSON:
		m.ClearPayloadJSON()
		return nil
	}
	return fmt.Errorf("unknown ToolEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolEventMutation) ResetField(name string) error {
	switch name {
	case toolevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	case toolevent.FieldEventType:
		m.ResetEventType()
		return nil
	case toolevent.FieldPayloadJSON:
		m.ResetPayloadJSON()
		return nil
	case toolevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ToolEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ToolEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ToolEvent edge %s", name)
}

// ToolSessionMutation represents an operation that mutates the ToolSession nodes in the graph.
type ToolSessionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	owner               *string
	source              *string
	channel             *string
	conversation_key    *string
	tool                *string
	title               *string
	command             *string
	workdir             *string
	state               *string
	access_mode         *string
	access_secret_hash  *string
	access_once_used_at *time.Time
	pinned              *bool
	last_active_at      *time.Time
	detached_at         *time.Time
	terminated_at       *time.Time
	expires_at          *time.Time
	metadata_json       *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ToolSession, error)
	predicates          []predicate.ToolSession
}

var _ ent.Mutation = (*ToolSessionMutation)(nil)

// toolsessionOption allows management of the mutation configuration using functional options.
type toolsessionOption func(*ToolSessionMutation)

// newToolSessionMutation creates new mutation for the ToolSession entity.
func newToolSessionMutation(c config, op Op, opts ...toolsessionOption) *ToolSessionMutation {
	m := &ToolSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeToolSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolSessionID sets the ID field of the mutation.
func withToolSessionID(id string) toolsessionOption {
	return func(m *ToolSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolSession
		)
		m.oldValue = func(ctx context.Context) (*ToolSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolSession sets the old ToolSession of the mutation.
func withToolSession(node *ToolSession) toolsessionOption {
	return func(m *ToolSessionMutation) {
		m.oldValue = func(context.Context) (*ToolSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ToolSession entities.
func (m *ToolSessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolSessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolSessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwner sets the "owner" field.
func (m *ToolSessionMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *ToolSessionMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *ToolSessionMutation) ResetOwner() {
	m.owner = nil
}

// SetSource sets the "source" field.
func (m *ToolSessionMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ToolSessionMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ToolSessionMutation) ResetSource() {
	m.source = nil
}

// SetChannel sets the "channel" field.
func (m *ToolSessionMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ToolSessionMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ClearChannel clears the value of the "channel" field.
func (m *ToolSessionMutation) ClearChannel() {
	m.channel = nil
	m.clearedFields[toolsession.FieldChannel] = struct{}{}
}

// ChannelCleared returns if the "channel" field was cleared in this mutation.
func (m *ToolSessionMutation) ChannelCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldChannel]
	return ok
}

// ResetChannel resets all changes to the "channel" field.
func (m *ToolSessionMutation) ResetChannel() {
	m.channel = nil
	delete(m.clearedFields, toolsession.FieldChannel)
}

// SetConversationKey sets the "conversation_key" field.
func (m *ToolSessionMutation) SetConversationKey(s string) {
	m.conversation_key = &s
}

// ConversationKey returns the value of the "conversation_key" field in the mutation.
func (m *ToolSessionMutation) ConversationKey() (r string, exists bool) {
	v := m.conversation_key
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationKey returns the old "conversation_key" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldConversationKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationKey: %w", err)
	}
	return oldValue.ConversationKey, nil
}

// ClearConversationKey clears the value of the "conversation_key" field.
func (m *ToolSessionMutation) ClearConversationKey() {
	m.conversation_key = nil
	m.clearedFields[toolsession.FieldConversationKey] = struct{}{}
}

// ConversationKeyCleared returns if the "conversation_key" field was cleared in this mutation.
func (m *ToolSessionMutation) ConversationKeyCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldConversationKey]
	return ok
}

// ResetConversationKey resets all changes to the "conversation_key" field.
func (m *ToolSessionMutation) ResetConversationKey() {
	m.conversation_key = nil
	delete(m.clearedFields, toolsession.FieldConversationKey)
}

// SetTool sets the "tool" field.
func (m *ToolSessionMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *ToolSessionMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *ToolSessionMutation) ResetTool() {
	m.tool = nil
}

// SetTitle sets the "title" field.
func (m *ToolSessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ToolSessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ToolSessionMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[toolsession.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ToolSessionMutation) TitleCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ToolSessionMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, toolsession.FieldTitle)
}

// SetCommand sets the "command" field.
func (m *ToolSessionMutation) SetCommand(s string) {
	m.command = &s
}

// Command returns the value of the "command" field in the mutation.
func (m *ToolSessionMutation) Command() (r string, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old "command" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldCommand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ClearCommand clears the value of the "command" field.
func (m *ToolSessionMutation) ClearCommand() {
	m.command = nil
	m.clearedFields[toolsession.FieldCommand] = struct{}{}
}

// CommandCleared returns if the "command" field was cleared in this mutation.
func (m *ToolSessionMutation) CommandCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldCommand]
	return ok
}

// ResetCommand resets all changes to the "command" field.
func (m *ToolSessionMutation) ResetCommand() {
	m.command = nil
	delete(m.clearedFields, toolsession.FieldCommand)
}

// SetWorkdir sets the "workdir" field.
func (m *ToolSessionMutation) SetWorkdir(s string) {
	m.workdir = &s
}

// Workdir returns the value of the "workdir" field in the mutation.
func (m *ToolSessionMutation) Workdir() (r string, exists bool) {
	v := m.workdir
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkdir returns the old "workdir" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldWorkdir(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkdir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkdir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkdir: %w", err)
	}
	return oldValue.Workdir, nil
}

// ClearWorkdir clears the value of the "workdir" field.
func (m *ToolSessionMutation) ClearWorkdir() {
	m.workdir = nil
	m.clearedFields[toolsession.FieldWorkdir] = struct{}{}
}

// WorkdirCleared returns if the "workdir" field was cleared in this mutation.
func (m *ToolSessionMutation) WorkdirCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldWorkdir]
	return ok
}

// ResetWorkdir resets all changes to the "workdir" field.
func (m *ToolSessionMutation) ResetWorkdir() {
	m.workdir = nil
	delete(m.clearedFields, toolsession.FieldWorkdir)
}

// SetState sets the "state" field.
func (m *ToolSessionMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *ToolSessionMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *ToolSessionMutation) ResetState() {
	m.state = nil
}

// SetAccessMode sets the "access_mode" field.
func (m *ToolSessionMutation) SetAccessMode(s string) {
	m.access_mode = &s
}

// AccessMode returns the value of the "access_mode" field in the mutation.
func (m *ToolSessionMutation) AccessMode() (r string, exists bool) {
	v := m.access_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessMode returns the old "access_mode" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldAccessMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessMode: %w", err)
	}
	return oldValue.AccessMode, nil
}

// ResetAccessMode resets all changes to the "access_mode" field.
func (m *ToolSessionMutation) ResetAccessMode() {
	m.access_mode = nil
}

// SetAccessSecretHash sets the "access_secret_hash" field.
func (m *ToolSessionMutation) SetAccessSecretHash(s string) {
	m.access_secret_hash = &s
}

// AccessSecretHash returns the value of the "access_secret_hash" field in the mutation.
func (m *ToolSessionMutation) AccessSecretHash() (r string, exists bool) {
	v := m.access_secret_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessSecretHash returns the old "access_secret_hash" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldAccessSecretHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessSecretHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessSecretHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessSecretHash: %w", err)
	}
	return oldValue.AccessSecretHash, nil
}

// ClearAccessSecretHash clears the value of the "access_secret_hash" field.
func (m *ToolSessionMutation) ClearAccessSecretHash() {
	m.access_secret_hash = nil
	m.clearedFields[toolsession.FieldAccessSecretHash] = struct{}{}
}

// AccessSecretHashCleared returns if the "access_secret_hash" field was cleared in this mutation.
func (m *ToolSessionMutation) AccessSecretHashCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldAccessSecretHash]
	return ok
}

// ResetAccessSecretHash resets all changes to the "access_secret_hash" field.
func (m *ToolSessionMutation) ResetAccessSecretHash() {
	m.access_secret_hash = nil
	delete(m.clearedFields, toolsession.FieldAccessSecretHash)
}

// SetAccessOnceUsedAt sets the "access_once_used_at" field.
func (m *ToolSessionMutation) SetAccessOnceUsedAt(t time.Time) {
	m.access_once_used_at = &t
}

// AccessOnceUsedAt returns the value of the "access_once_used_at" field in the mutation.
func (m *ToolSessionMutation) AccessOnceUsedAt() (r time.Time, exists bool) {
	v := m.access_once_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOnceUsedAt returns the old "access_once_used_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldAccessOnceUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOnceUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOnceUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOnceUsedAt: %w", err)
	}
	return oldValue.AccessOnceUsedAt, nil
}

// ClearAccessOnceUsedAt clears the value of the "access_once_used_at" field.
func (m *ToolSessionMutation) ClearAccessOnceUsedAt() {
	m.access_once_used_at = nil
	m.clearedFields[toolsession.FieldAccessOnceUsedAt] = struct{}{}
}

// AccessOnceUsedAtCleared returns if the "access_once_used_at" field was cleared in this mutation.
func (m *ToolSessionMutation) AccessOnceUsedAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldAccessOnceUsedAt]
	return ok
}

// ResetAccessOnceUsedAt resets all changes to the "access_once_used_at" field.
func (m *ToolSessionMutation) ResetAccessOnceUsedAt() {
	m.access_once_used_at = nil
	delete(m.clearedFields, toolsession.FieldAccessOnceUsedAt)
}

// SetPinned sets the "pinned" field.
func (m *ToolSessionMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *ToolSessionMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *ToolSessionMutation) ResetPinned() {
	m.pinned = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *ToolSessionMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *ToolSessionMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *ToolSessionMutation) ResetLastActiveAt() {
	m.last_active_at = nil
}

// SetDetachedAt sets the "detached_at" field.
func (m *ToolSessionMutation) SetDetachedAt(t time.Time) {
	m.detached_at = &t
}

// DetachedAt returns the value of the "detached_at" field in the mutation.
func (m *ToolSessionMutation) DetachedAt() (r time.Time, exists bool) {
	v := m.detached_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDetachedAt returns the old "detached_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldDetachedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetachedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetachedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetachedAt: %w", err)
	}
	return oldValue.DetachedAt, nil
}

// ClearDetachedAt clears the value of the "detached_at" field.
func (m *ToolSessionMutation) ClearDetachedAt() {
	m.detached_at = nil
	m.clearedFields[toolsession.FieldDetachedAt] = struct{}{}
}

// DetachedAtCleared returns if the "detached_at" field was cleared in this mutation.
func (m *ToolSessionMutation) DetachedAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldDetachedAt]
	return ok
}

// ResetDetachedAt resets all changes to the "detached_at" field.
func (m *ToolSessionMutation) ResetDetachedAt() {
	m.detached_at = nil
	delete(m.clearedFields, toolsession.FieldDetachedAt)
}

// SetTerminatedAt sets the "terminated_at" field.
func (m *ToolSessionMutation) SetTerminatedAt(t time.Time) {
	m.terminated_at = &t
}

// TerminatedAt returns the value of the "terminated_at" field in the mutation.
func (m *ToolSessionMutation) TerminatedAt() (r time.Time, exists bool) {
	v := m.terminated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminatedAt returns the old "terminated_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldTerminatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerminatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerminatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminatedAt: %w", err)
	}
	return oldValue.TerminatedAt, nil
}

// ClearTerminatedAt clears the value of the "terminated_at" field.
func (m *ToolSessionMutation) ClearTerminatedAt() {
	m.terminated_at = nil
	m.clearedFields[toolsession.FieldTerminatedAt] = struct{}{}
}

// TerminatedAtCleared returns if the "terminated_at" field was cleared in this mutation.
func (m *ToolSessionMutation) TerminatedAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldTerminatedAt]
	return ok
}

// ResetTerminatedAt resets all changes to the "terminated_at" field.
func (m *ToolSessionMutation) ResetTerminatedAt() {
	m.terminated_at = nil
	delete(m.clearedFields, toolsession.FieldTerminatedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ToolSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ToolSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ToolSessionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[toolsession.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ToolSessionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ToolSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, toolsession.FieldExpiresAt)
}

// SetMetadataJSON sets the "metadata_json" field.
func (m *ToolSessionMutation) SetMetadataJSON(s string) {
	m.metadata_json = &s
}

// MetadataJSON returns the value of the "metadata_json" field in the mutation.
func (m *ToolSessionMutation) MetadataJSON() (r string, exists bool) {
	v := m.metadata_json
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataJSON returns the old "metadata_json" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldMetadataJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataJSON: %w", err)
	}
	return oldValue.MetadataJSON, nil
}

// ClearMetadataJSON clears the value of the "metadata_json" field.
func (m *ToolSessionMutation) ClearMetadataJSON() {
	m.metadata_json = nil
	m.clearedFields[toolsession.FieldMetadataJSON] = struct{}{}
}

// MetadataJSONCleared returns if the "metadata_json" field was cleared in this mutation.
func (m *ToolSessionMutation) MetadataJSONCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldMetadataJSON]
	return ok
}

// ResetMetadataJSON resets all changes to the "metadata_json" field.
func (m *ToolSessionMutation) ResetMetadataJSON() {
	m.metadata_json = nil
	delete(m.clearedFields, toolsession.FieldMetadataJSON)
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ToolSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ToolSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ToolSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ToolSessionMutation builder.
func (m *ToolSessionMutation) Where(ps ...predicate.ToolSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolSession).
func (m *ToolSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolSessionMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.owner != nil {
		fields = append(fields, toolsession.FieldOwner)
	}
	if m.source != nil {
		fields = append(fields, toolsession.FieldSource)
	}
	if m.channel != nil {
		fields = append(fields, toolsession.FieldChannel)
	}
	if m.conversation_key != nil {
		fields = append(fields, toolsession.FieldConversationKey)
	}
	if m.tool != nil {
		fields = append(fields, toolsession.FieldTool)
	}
	if m.title != nil {
		fields = append(fields, toolsession.FieldTitle)
	}
	if m.command != nil {
		fields = append(fields, toolsession.FieldCommand)
	}
	if m.workdir != nil {
		fields = append(fields, toolsession.FieldWorkdir)
	}
	if m.state != nil {
		fields = append(fields, toolsession.FieldState)
	}
	if m.access_mode != nil {
		fields = append(fields, toolsession.FieldAccessMode)
	}
	if m.access_secret_hash != nil {
		fields = append(fields, toolsession.FieldAccessSecretHash)
	}
	if m.access_once_used_at != nil {
		fields = append(fields, toolsession.FieldAccessOnceUsedAt)
	}
	if m.pinned != nil {
		fields = append(fields, toolsession.FieldPinned)
	}
	if m.last_active_at != nil {
		fields = append(fields, toolsession.FieldLastActiveAt)
	}
	if m.detached_at != nil {
		fields = append(fields, toolsession.FieldDetachedAt)
	}
	if m.terminated_at != nil {
		fields = append(fields, toolsession.FieldTerminatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, toolsession.FieldExpiresAt)
	}
	if m.metadata_json != nil {
		fields = append(fields, toolsession.FieldMetadataJSON)
	}
	if m.created_at != nil {
		fields = append(fields, toolsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, toolsession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolsession.FieldOwner:
		return m.Owner()
	case toolsession.FieldSource:
		return m.Source()
	case toolsession.FieldChannel:
		return m.Channel()
	case toolsession.FieldConversationKey:
		return m.ConversationKey()
	case toolsession.FieldTool:
		return m.Tool()
	case toolsession.FieldTitle:
		return m.Title()
	case toolsession.FieldCommand:
		return m.Command()
	case toolsession.FieldWorkdir:
		return m.Workdir()
	case toolsession.FieldState:
		return m.State()
	case toolsession.FieldAccessMode:
		return m.AccessMode()
	case toolsession.FieldAccessSecretHash:
		return m.AccessSecretHash()
	case toolsession.FieldAccessOnceUsedAt:
		return m.AccessOnceUsedAt()
	case toolsession.FieldPinned:
		return m.Pinned()
	case toolsession.FieldLastActiveAt:
		return m.LastActiveAt()
	case toolsession.FieldDetachedAt:
		return m.DetachedAt()
	case toolsession.FieldTerminatedAt:
		return m.TerminatedAt()
	case toolsession.FieldExpiresAt:
		return m.ExpiresAt()
	case toolsession.FieldMetadataJSON:
		return m.MetadataJSON()
	case toolsession.FieldCreatedAt:
		return m.CreatedAt()
	case toolsession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolsession.FieldOwner:
		return m.OldOwner(ctx)
	case toolsession.FieldSource:
		return m.OldSource(ctx)
	case toolsession.FieldChannel:
		return m.OldChannel(ctx)
	case toolsession.FieldConversationKey:
		return m.OldConversationKey(ctx)
	case toolsession.FieldTool:
		return m.OldTool(ctx)
	case toolsession.FieldTitle:
		return m.OldTitle(ctx)
	case toolsession.FieldCommand:
		return m.OldCommand(ctx)
	case toolsession.FieldWorkdir:
		return m.OldWorkdir(ctx)
	case toolsession.FieldState:
		return m.OldState(ctx)
	case toolsession.FieldAccessMode:
		return m.OldAccessMode(ctx)
	case toolsession.FieldAccessSecretHash:
		return m.OldAccessSecretHash(ctx)
	case toolsession.FieldAccessOnceUsedAt:
		return m.OldAccessOnceUsedAt(ctx)
	case toolsession.FieldPinned:
		return m.OldPinned(ctx)
	case toolsession.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case toolsession.FieldDetachedAt:
		return m.OldDetachedAt(ctx)
	case toolsession.FieldTerminatedAt:
		return m.OldTerminatedAt(ctx)
	case toolsession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case toolsession.FieldMetadataJSON:
		return m.OldMetadataJSON(ctx)
	case toolsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case toolsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ToolSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolsession.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case toolsession.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case toolsession.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case toolsession.FieldConversationKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationKey(v)
		return nil
	case toolsession.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	case toolsession.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case toolsession.FieldCommand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case toolsession.FieldWorkdir:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkdir(v)
		return nil
	case toolsession.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case toolsession.FieldAccessMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessMode(v)
		return nil
	case toolsession.FieldAccessSecretHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessSecretHash(v)
		return nil
	case toolsession.FieldAccessOnceUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOnceUsedAt(v)
		return nil
	case toolsession.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case toolsession.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case toolsession.FieldDetachedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetachedAt(v)
		return nil
	case toolsession.FieldTerminatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminatedAt(v)
		return nil
	case toolsession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case toolsession.FieldMetadataJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataJSON(v)
		return nil
	case toolsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case toolsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ToolSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ToolSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolsession.FieldChannel) {
		fields = append(fields, toolsession.FieldChannel)
	}
	if m.FieldCleared(toolsession.FieldConversationKey) {
		fields = append(fields, toolsession.FieldConversationKey)
	}
	if m.FieldCleared(toolsession.FieldTitle) {
		fields = append(fields, toolsession.FieldTitle)
	}
	if m.FieldCleared(toolsession.FieldCommand) {
		fields = append(fields, toolsession.FieldCommand)
	}
	if m.FieldCleared(toolsession.FieldWorkdir) {
		fields = append(fields, toolsession.FieldWorkdir)
	}
	if m.FieldCleared(toolsession.FieldAccessSecretHash) {
		fields = append(fields, toolsession.FieldAccessSecretHash)
	}
	if m.FieldCleared(toolsession.FieldAccessOnceUsedAt) {
		fields = append(fields, toolsession.FieldAccessOnceUsedAt)
	}
	if m.FieldCleared(toolsession.FieldDetachedAt) {
		fields = append(fields, toolsession.FieldDetachedAt)
	}
	if m.FieldCleared(toolsession.FieldTerminatedAt) {
		fields = append(fields, toolsession.FieldTerminatedAt)
	}
	if m.FieldCleared(toolsession.FieldExpiresAt) {
		fields = append(fields, toolsession.FieldExpiresAt)
	}
	if m.FieldCleared(toolsession.FieldMetadataJSON) {
		fields = append(fields, toolsession.FieldMetadataJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolSessionMutation) ClearField(name string) error {
	switch name {
	case toolsession.FieldChannel:
		m.ClearChannel()
		return nil
	case toolsession.FieldConversationKey:
		m.ClearConversationKey()
		return nil
	case toolsession.FieldTitle:
		m.ClearTitle()
		return nil
	case toolsession.FieldCommand:
		m.ClearCommand()
		return nil
	case toolsession.FieldWorkdir:
		m.ClearWorkdir()
		return nil
	case toolsession.FieldAccessSecretHash:
		m.ClearAccessSecretHash()
		return nil
	case toolsession.FieldAccessOnceUsedAt:
		m.ClearAccessOnceUsedAt()
		return nil
	case toolsession.FieldDetachedAt:
		m.ClearDetachedAt()
		return nil
	case toolsession.FieldTerminatedAt:
		m.ClearTerminatedAt()
		return nil
	case toolsession.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case toolsession.FieldMetadataJSON:
		m.ClearMetadataJSON()
		return nil
	}
	return fmt.Errorf("unknown ToolSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolSessionMutation) ResetField(name string) error {
	switch name {
	case toolsession.FieldOwner:
		m.ResetOwner()
		return nil
	case toolsession.FieldSource:
		m.ResetSource()
		return nil
	case toolsession.FieldChannel:
		m.ResetChannel()
		return nil
	case toolsession.FieldConversationKey:
		m.ResetConversationKey()
		return nil
	case toolsession.FieldTool:
		m.ResetTool()
		return nil
	case toolsession.FieldTitle:
		m.ResetTitle()
		return nil
	case toolsession.FieldCommand:
		m.ResetCommand()
		return nil
	case toolsession.FieldWorkdir:
		m.ResetWorkdir()
		return nil
	case toolsession.FieldState:
		m.ResetState()
		return nil
	case toolsession.FieldAccessMode:
		m.ResetAccessMode()
		return nil
	case toolsession.FieldAccessSecretHash:
		m.ResetAccessSecretHash()
		return nil
	case toolsession.FieldAccessOnceUsedAt:
		m.ResetAccessOnceUsedAt()
		return nil
	case toolsession.FieldPinned:
		m.ResetPinned()
		return nil
	case toolsession.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case toolsession.FieldDetachedAt:
		m.ResetDetachedAt()
		return nil
	case toolsession.FieldTerminatedAt:
		m.ResetTerminatedAt()
		return nil
	case toolsession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case toolsession.FieldMetadataJSON:
		m.ResetMetadataJSON()
		return nil
	case toolsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case toolsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ToolSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ToolSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ToolSession edge %s", name)
}

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"nekobot/pkg/toolsessions/ent/attachtoken"
	"nekobot/pkg/toolsessions/ent/predicate"
	"nekobot/pkg/toolsessions/ent/toolevent"
	"nekobot/pkg/toolsessions/ent/toolsession"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachToken = "AttachToken"
	TypeToolEvent   = "ToolEvent"
	TypeToolSession = "ToolSession"
)

// AttachTokenMutation represents an operation that mutates the AttachToken nodes in the graph.
type AttachTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	token         *string
	session_id    *string
	owner         *string
	expires_at    *time.Time
	used_at       *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AttachToken, error)
	predicates    []predicate.AttachToken
}

var _ ent.Mutation = (*AttachTokenMutation)(nil)

// attachtokenOption allows management of the mutation configuration using functional options.
type attachtokenOption func(*AttachTokenMutation)

// newAttachTokenMutation creates new mutation for the AttachToken entity.
func newAttachTokenMutation(c config, op Op, opts ...attachtokenOption) *AttachTokenMutation {
	m := &AttachTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachTokenID sets the ID field of the mutation.
func withAttachTokenID(id string) attachtokenOption {
	return func(m *AttachTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AttachToken
		)
		m.oldValue = func(ctx context.Context) (*AttachToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttachToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachToken sets the old AttachToken of the mutation.
func withAttachToken(node *AttachToken) attachtokenOption {
	return func(m *AttachTokenMutation) {
		m.oldValue = func(context.Context) (*AttachToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AttachToken entities.
func (m *AttachTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttachToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *AttachTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AttachTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AttachTokenMutation) ResetToken() {
	m.token = nil
}

// SetSessionID sets the "session_id" field.
func (m *AttachTokenMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *AttachTokenMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *AttachTokenMutation) ResetSessionID() {
	m.session_id = nil
}

// SetOwner sets the "owner" field.
func (m *AttachTokenMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *AttachTokenMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *AttachTokenMutation) ResetOwner() {
	m.owner = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AttachTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AttachTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AttachTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *AttachTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *AttachTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *AttachTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[attachtoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *AttachTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[attachtoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *AttachTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, attachtoken.FieldUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AttachToken entity.
// If the AttachToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AttachTokenMutation builder.
func (m *AttachTokenMutation) Where(ps ...predicate.AttachToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttachToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttachToken).
func (m *AttachTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.token != nil {
		fields = append(fields, attachtoken.FieldToken)
	}
	if m.session_id != nil {
		fields = append(fields, attachtoken.FieldSessionID)
	}
	if m.owner != nil {
		fields = append(fields, attachtoken.FieldOwner)
	}
	if m.expires_at != nil {
		fields = append(fields, attachtoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, attachtoken.FieldUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, attachtoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachtoken.FieldToken:
		return m.Token()
	case attachtoken.FieldSessionID:
		return m.SessionID()
	case attachtoken.FieldOwner:
		return m.Owner()
	case attachtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case attachtoken.FieldUsedAt:
		return m.UsedAt()
	case attachtoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachtoken.FieldToken:
		return m.OldToken(ctx)
	case attachtoken.FieldSessionID:
		return m.OldSessionID(ctx)
	case attachtoken.FieldOwner:
		return m.OldOwner(ctx)
	case attachtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case attachtoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case attachtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AttachToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachtoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case attachtoken.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case attachtoken.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case attachtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case attachtoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case attachtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AttachToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AttachToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachtoken.FieldUsedAt) {
		fields = append(fields, attachtoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachTokenMutation) ClearField(name string) error {
	switch name {
	case attachtoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown AttachToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachTokenMutation) ResetField(name string) error {
	switch name {
	case attachtoken.FieldToken:
		m.ResetToken()
		return nil
	case attachtoken.FieldSessionID:
		m.ResetSessionID()
		return nil
	case attachtoken.FieldOwner:
		m.ResetOwner()
		return nil
	case attachtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case attachtoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case attachtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AttachToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AttachToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AttachToken edge %s", name)
}

// ToolEventMutation represents an operation that mutates the ToolEvent nodes in the graph.
type ToolEventMutation struct {
	config
	op            Op
	typ           string
	id            *string
	session_id    *string
	event_type    *string
	payload_json  *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ToolEvent, error)
	predicates    []predicate.ToolEvent
}

var _ ent.Mutation = (*ToolEventMutation)(nil)

// tooleventOption allows management of the mutation configuration using functional options.
type tooleventOption func(*ToolEventMutation)

// newToolEventMutation creates new mutation for the ToolEvent entity.
func newToolEventMutation(c config, op Op, opts ...tooleventOption) *ToolEventMutation {
	m := &ToolEventMutation{
		config:        c,
		op:            op,
		typ:           TypeToolEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolEventID sets the ID field of the mutation.
func withToolEventID(id string) tooleventOption {
	return func(m *ToolEventMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolEvent
		)
		m.oldValue = func(ctx context.Context) (*ToolEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolEvent sets the old ToolEvent of the mutation.
func withToolEvent(node *ToolEvent) tooleventOption {
	return func(m *ToolEventMutation) {
		m.oldValue = func(context.Context) (*ToolEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ToolEvent entities.
func (m *ToolEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *ToolEventMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *ToolEventMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *ToolEventMutation) ResetSessionID() {
	m.session_id = nil
}

// SetEventType sets the "event_type" field.
func (m *ToolEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ToolEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ToolEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetPayloadJSON sets the "payload_json" field.
func (m *ToolEventMutation) SetPayloadJSON(s string) {
	m.payload_json = &s
}

// PayloadJSON returns the value of the "payload_json" field in the mutation.
func (m *ToolEventMutation) PayloadJSON() (r string, exists bool) {
	v := m.payload_json
	if v == nil {
		return
	}
	return *v, true
}

// OldPayloadJSON returns the old "payload_json" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldPayloadJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayloadJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayloadJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayloadJSON: %w", err)
	}
	return oldValue.PayloadJSON, nil
}

// ClearPayloadJSON clears the value of the "payload_json" field.
func (m *ToolEventMutation) ClearPayloadJSON() {
	m.payload_json = nil
	m.clearedFields[toolevent.FieldPayloadJSON] = struct{}{}
}

// PayloadJSONCleared returns if the "payload_json" field was cleared in this mutation.
func (m *ToolEventMutation) PayloadJSONCleared() bool {
	_, ok := m.clearedFields[toolevent.FieldPayloadJSON]
	return ok
}

// ResetPayloadJSON resets all changes to the "payload_json" field.
func (m *ToolEventMutation) ResetPayloadJSON() {
	m.payload_json = nil
	delete(m.clearedFields, toolevent.FieldPayloadJSON)
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolEvent entity.
// If the ToolEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ToolEventMutation builder.
func (m *ToolEventMutation) Where(ps ...predicate.ToolEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolEvent).
func (m *ToolEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolEventMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.session_id != nil {
		fields = append(fields, toolevent.FieldSessionID)
	}
	if m.event_type != nil {
		fields = append(fields, toolevent.FieldEventType)
	}
	if m.payload_json != nil {
		fields = append(fields, toolevent.FieldPayloadJSON)
	}
	if m.created_at != nil {
		fields = append(fields, toolevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolevent.FieldSessionID:
		return m.SessionID()
	case toolevent.FieldEventType:
		return m.EventType()
	case toolevent.FieldPayloadJSON:
		return m.PayloadJSON()
	case toolevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolevent.FieldSessionID:
		return m.OldSessionID(ctx)
	case toolevent.FieldEventType:
		return m.OldEventType(ctx)
	case toolevent.FieldPayloadJSON:
		return m.OldPayloadJSON(ctx)
	case toolevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ToolEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolevent.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case toolevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case toolevent.FieldPayloadJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayloadJSON(v)
		return nil
	case toolevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ToolEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ToolEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolevent.FieldPayloadJSON) {
		fields = append(fields, toolevent.FieldPayloadJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolEventMutation) ClearField(name string) error {
	switch name {
	case toolevent.FieldPayloadJSON:
		m.ClearPayloadJSON()
		return nil
	}
	return fmt.Errorf("unknown ToolEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolEventMutation) ResetField(name string) error {
	switch name {
	case toolevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	case toolevent.FieldEventType:
		m.ResetEventType()
		return nil
	case toolevent.FieldPayloadJSON:
		m.ResetPayloadJSON()
		return nil
	case toolevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ToolEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ToolEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ToolEvent edge %s", name)
}

// ToolSessionMutation represents an operation that mutates the ToolSession nodes in the graph.
type ToolSessionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	owner               *string
	source              *string
	channel             *string
	conversation_key    *string
	tool                *string
	title               *string
	command             *string
	workdir             *string
	state               *string
	access_mode         *string
	access_secret_hash  *string
	access_once_used_at *time.Time
	pinned              *bool
	last_active_at      *time.Time
	detached_at         *time.Time
	terminated_at       *time.Time
	expires_at          *time.Time
	metadata_json       *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ToolSession, error)
	predicates          []predicate.ToolSession
}

var _ ent.Mutation = (*ToolSessionMutation)(nil)

// toolsessionOption allows management of the mutation configuration using functional options.
type toolsessionOption func(*ToolSessionMutation)

// newToolSessionMutation creates new mutation for the ToolSession entity.
func newToolSessionMutation(c config, op Op, opts ...toolsessionOption) *ToolSessionMutation {
	m := &ToolSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeToolSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolSessionID sets the ID field of the mutation.
func withToolSessionID(id string) toolsessionOption {
	return func(m *ToolSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolSession
		)
		m.oldValue = func(ctx context.Context) (*ToolSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolSession sets the old ToolSession of the mutation.
func withToolSession(node *ToolSession) toolsessionOption {
	return func(m *ToolSessionMutation) {
		m.oldValue = func(context.Context) (*ToolSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ToolSession entities.
func (m *ToolSessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolSessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolSessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwner sets the "owner" field.
func (m *ToolSessionMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *ToolSessionMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *ToolSessionMutation) ResetOwner() {
	m.owner = nil
}

// SetSource sets the "source" field.
func (m *ToolSessionMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ToolSessionMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ToolSessionMutation) ResetSource() {
	m.source = nil
}

// SetChannel sets the "channel" field.
func (m *ToolSessionMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ToolSessionMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ClearChannel clears the value of the "channel" field.
func (m *ToolSessionMutation) ClearChannel() {
	m.channel = nil
	m.clearedFields[toolsession.FieldChannel] = struct{}{}
}

// ChannelCleared returns if the "channel" field was cleared in this mutation.
func (m *ToolSessionMutation) ChannelCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldChannel]
	return ok
}

// ResetChannel resets all changes to the "channel" field.
func (m *ToolSessionMutation) ResetChannel() {
	m.channel = nil
	delete(m.clearedFields, toolsession.FieldChannel)
}

// SetConversationKey sets the "conversation_key" field.
func (m *ToolSessionMutation) SetConversationKey(s string) {
	m.conversation_key = &s
}

// ConversationKey returns the value of the "conversation_key" field in the mutation.
func (m *ToolSessionMutation) ConversationKey() (r string, exists bool) {
	v := m.conversation_key
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationKey returns the old "conversation_key" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldConversationKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationKey: %w", err)
	}
	return oldValue.ConversationKey, nil
}

// ClearConversationKey clears the value of the "conversation_key" field.
func (m *ToolSessionMutation) ClearConversationKey() {
	m.conversation_key = nil
	m.clearedFields[toolsession.FieldConversationKey] = struct{}{}
}

// ConversationKeyCleared returns if the "conversation_key" field was cleared in this mutation.
func (m *ToolSessionMutation) ConversationKeyCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldConversationKey]
	return ok
}

// ResetConversationKey resets all changes to the "conversation_key" field.
func (m *ToolSessionMutation) ResetConversationKey() {
	m.conversation_key = nil
	delete(m.clearedFields, toolsession.FieldConversationKey)
}

// SetTool sets the "tool" field.
func (m *ToolSessionMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *ToolSessionMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *ToolSessionMutation) ResetTool() {
	m.tool = nil
}

// SetTitle sets the "title" field.
func (m *ToolSessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ToolSessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ToolSessionMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[toolsession.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ToolSessionMutation) TitleCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ToolSessionMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, toolsession.FieldTitle)
}

// SetCommand sets the "command" field.
func (m *ToolSessionMutation) SetCommand(s string) {
	m.command = &s
}

// Command returns the value of the "command" field in the mutation.
func (m *ToolSessionMutation) Command() (r string, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old "command" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldCommand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ClearCommand clears the value of the "command" field.
func (m *ToolSessionMutation) ClearCommand() {
	m.command = nil
	m.clearedFields[toolsession.FieldCommand] = struct{}{}
}

// CommandCleared returns if the "command" field was cleared in this mutation.
func (m *ToolSessionMutation) CommandCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldCommand]
	return ok
}

// ResetCommand resets all changes to the "command" field.
func (m *ToolSessionMutation) ResetCommand() {
	m.command = nil
	delete(m.clearedFields, toolsession.FieldCommand)
}

// SetWorkdir sets the "workdir" field.
func (m *ToolSessionMutation) SetWorkdir(s string) {
	m.workdir = &s
}

// Workdir returns the value of the "workdir" field in the mutation.
func (m *ToolSessionMutation) Workdir() (r string, exists bool) {
	v := m.workdir
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkdir returns the old "workdir" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldWorkdir(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkdir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkdir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkdir: %w", err)
	}
	return oldValue.Workdir, nil
}

// ClearWorkdir clears the value of the "workdir" field.
func (m *ToolSessionMutation) ClearWorkdir() {
	m.workdir = nil
	m.clearedFields[toolsession.FieldWorkdir] = struct{}{}
}

// WorkdirCleared returns if the "workdir" field was cleared in this mutation.
func (m *ToolSessionMutation) WorkdirCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldWorkdir]
	return ok
}

// ResetWorkdir resets all changes to the "workdir" field.
func (m *ToolSessionMutation) ResetWorkdir() {
	m.workdir = nil
	delete(m.clearedFields, toolsession.FieldWorkdir)
}

// SetState sets the "state" field.
func (m *ToolSessionMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *ToolSessionMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *ToolSessionMutation) ResetState() {
	m.state = nil
}

// SetAccessMode sets the "access_mode" field.
func (m *ToolSessionMutation) SetAccessMode(s string) {
	m.access_mode = &s
}

// AccessMode returns the value of the "access_mode" field in the mutation.
func (m *ToolSessionMutation) AccessMode() (r string, exists bool) {
	v := m.access_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessMode returns the old "access_mode" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldAccessMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessMode: %w", err)
	}
	return oldValue.AccessMode, nil
}

// ResetAccessMode resets all changes to the "access_mode" field.
func (m *ToolSessionMutation) ResetAccessMode() {
	m.access_mode = nil
}

// SetAccessSecretHash sets the "access_secret_hash" field.
func (m *ToolSessionMutation) SetAccessSecretHash(s string) {
	m.access_secret_hash = &s
}

// AccessSecretHash returns the value of the "access_secret_hash" field in the mutation.
func (m *ToolSessionMutation) AccessSecretHash() (r string, exists bool) {
	v := m.access_secret_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessSecretHash returns the old "access_secret_hash" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldAccessSecretHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessSecretHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessSecretHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessSecretHash: %w", err)
	}
	return oldValue.AccessSecretHash, nil
}

// ClearAccessSecretHash clears the value of the "access_secret_hash" field.
func (m *ToolSessionMutation) ClearAccessSecretHash() {
	m.access_secret_hash = nil
	m.clearedFields[toolsession.FieldAccessSecretHash] = struct{}{}
}

// AccessSecretHashCleared returns if the "access_secret_hash" field was cleared in this mutation.
func (m *ToolSessionMutation) AccessSecretHashCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldAccessSecretHash]
	return ok
}

// ResetAccessSecretHash resets all changes to the "access_secret_hash" field.
func (m *ToolSessionMutation) ResetAccessSecretHash() {
	m.access_secret_hash = nil
	delete(m.clearedFields, toolsession.FieldAccessSecretHash)
}

// SetAccessOnceUsedAt sets the "access_once_used_at" field.
func (m *ToolSessionMutation) SetAccessOnceUsedAt(t time.Time) {
	m.access_once_used_at = &t
}

// AccessOnceUsedAt returns the value of the "access_once_used_at" field in the mutation.
func (m *ToolSessionMutation) AccessOnceUsedAt() (r time.Time, exists bool) {
	v := m.access_once_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOnceUsedAt returns the old "access_once_used_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldAccessOnceUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOnceUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOnceUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOnceUsedAt: %w", err)
	}
	return oldValue.AccessOnceUsedAt, nil
}

// ClearAccessOnceUsedAt clears the value of the "access_once_used_at" field.
func (m *ToolSessionMutation) ClearAccessOnceUsedAt() {
	m.access_once_used_at = nil
	m.clearedFields[toolsession.FieldAccessOnceUsedAt] = struct{}{}
}

// AccessOnceUsedAtCleared returns if the "access_once_used_at" field was cleared in this mutation.
func (m *ToolSessionMutation) AccessOnceUsedAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldAccessOnceUsedAt]
	return ok
}

// ResetAccessOnceUsedAt resets all changes to the "access_once_used_at" field.
func (m *ToolSessionMutation) ResetAccessOnceUsedAt() {
	m.access_once_used_at = nil
	delete(m.clearedFields, toolsession.FieldAccessOnceUsedAt)
}

// SetPinned sets the "pinned" field.
func (m *ToolSessionMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *ToolSessionMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *ToolSessionMutation) ResetPinned() {
	m.pinned = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *ToolSessionMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *ToolSessionMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *ToolSessionMutation) ResetLastActiveAt() {
	m.last_active_at = nil
}

// SetDetachedAt sets the "detached_at" field.
func (m *ToolSessionMutation) SetDetachedAt(t time.Time) {
	m.detached_at = &t
}

// DetachedAt returns the value of the "detached_at" field in the mutation.
func (m *ToolSessionMutation) DetachedAt() (r time.Time, exists bool) {
	v := m.detached_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDetachedAt returns the old "detached_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldDetachedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetachedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetachedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetachedAt: %w", err)
	}
	return oldValue.DetachedAt, nil
}

// ClearDetachedAt clears the value of the "detached_at" field.
func (m *ToolSessionMutation) ClearDetachedAt() {
	m.detached_at = nil
	m.clearedFields[toolsession.FieldDetachedAt] = struct{}{}
}

// DetachedAtCleared returns if the "detached_at" field was cleared in this mutation.
func (m *ToolSessionMutation) DetachedAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldDetachedAt]
	return ok
}

// ResetDetachedAt resets all changes to the "detached_at" field.
func (m *ToolSessionMutation) ResetDetachedAt() {
	m.detached_at = nil
	delete(m.clearedFields, toolsession.FieldDetachedAt)
}

// SetTerminatedAt sets the "terminated_at" field.
func (m *ToolSessionMutation) SetTerminatedAt(t time.Time) {
	m.terminated_at = &t
}

// TerminatedAt returns the value of the "terminated_at" field in the mutation.
func (m *ToolSessionMutation) TerminatedAt() (r time.Time, exists bool) {
	v := m.terminated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminatedAt returns the old "terminated_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldTerminatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerminatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerminatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminatedAt: %w", err)
	}
	return oldValue.TerminatedAt, nil
}

// ClearTerminatedAt clears the value of the "terminated_at" field.
func (m *ToolSessionMutation) ClearTerminatedAt() {
	m.terminated_at = nil
	m.clearedFields[toolsession.FieldTerminatedAt] = struct{}{}
}

// TerminatedAtCleared returns if the "terminated_at" field was cleared in this mutation.
func (m *ToolSessionMutation) TerminatedAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldTerminatedAt]
	return ok
}

// ResetTerminatedAt resets all changes to the "terminated_at" field.
func (m *ToolSessionMutation) ResetTerminatedAt() {
	m.terminated_at = nil
	delete(m.clearedFields, toolsession.FieldTerminatedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ToolSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ToolSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ToolSessionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[toolsession.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ToolSessionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ToolSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, toolsession.FieldExpiresAt)
}

// SetMetadataJSON sets the "metadata_json" field.
func (m *ToolSessionMutation) SetMetadataJSON(s string) {
	m.metadata_json = &s
}

// MetadataJSON returns the value of the "metadata_json" field in the mutation.
func (m *ToolSessionMutation) MetadataJSON() (r string, exists bool) {
	v := m.metadata_json
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataJSON returns the old "metadata_json" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldMetadataJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataJSON: %w", err)
	}
	return oldValue.MetadataJSON, nil
}

// ClearMetadataJSON clears the value of the "metadata_json" field.
func (m *ToolSessionMutation) ClearMetadataJSON() {
	m.metadata_json = nil
	m.clearedFields[toolsession.FieldMetadataJSON] = struct{}{}
}

// MetadataJSONCleared returns if the "metadata_json" field was cleared in this mutation.
func (m *ToolSessionMutation) MetadataJSONCleared() bool {
	_, ok := m.clearedFields[toolsession.FieldMetadataJSON]
	return ok
}

// ResetMetadataJSON resets all changes to the "metadata_json" field.
func (m *ToolSessionMutation) ResetMetadataJSON() {
	m.metadata_json = nil
	delete(m.clearedFields, toolsession.FieldMetadataJSON)
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ToolSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ToolSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ToolSession entity.
// If the ToolSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ToolSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ToolSessionMutation builder.
func (m *ToolSessionMutation) Where(ps ...predicate.ToolSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolSession).
func (m *ToolSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolSessionMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.owner != nil {
		fields = append(fields, toolsession.FieldOwner)
	}
	if m.source != nil {
		fields = append(fields, toolsession.FieldSource)
	}
	if m.channel != nil {
		fields = append(fields, toolsession.FieldChannel)
	}
	if m.conversation_key != nil {
		fields = append(fields, toolsession.FieldConversationKey)
	}
	if m.tool != nil {
		fields = append(fields, toolsession.FieldTool)
	}
	if m.title != nil {
		fields = append(fields, toolsession.FieldTitle)
	}
	if m.command != nil {
		fields = append(fields, toolsession.FieldCommand)
	}
	if m.workdir != nil {
		fields = append(fields, toolsession.FieldWorkdir)
	}
	if m.state != nil {
		fields = append(fields, toolsession.FieldState)
	}
	if m.access_mode != nil {
		fields = append(fields, toolsession.FieldAccessMode)
	}
	if m.access_secret_hash != nil {
		fields = append(fields, toolsession.FieldAccessSecretHash)
	}
	if m.access_once_used_at != nil {
		fields = append(fields, toolsession.FieldAccessOnceUsedAt)
	}
	if m.pinned != nil {
		fields = append(fields, toolsession.FieldPinned)
	}
	if m.last_active_at != nil {
		fields = append(fields, toolsession.FieldLastActiveAt)
	}
	if m.detached_at != nil {
		fields = append(fields, toolsession.FieldDetachedAt)
	}
	if m.terminated_at != nil {
		fields = append(fields, toolsession.FieldTerminatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, toolsession.FieldExpiresAt)
	}
	if m.metadata_json != nil {
		fields = append(fields, toolsession.FieldMetadataJSON)
	}
	if m.created_at != nil {
		fields = append(fields, toolsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, toolsession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolsession.FieldOwner:
		return m.Owner()
	case toolsession.FieldSource:
		return m.Source()
	case toolsession.FieldChannel:
		return m.Channel()
	case toolsession.FieldConversationKey:
		return m.ConversationKey()
	case toolsession.FieldTool:
		return m.Tool()
	case toolsession.FieldTitle:
		return m.Title()
	case toolsession.FieldCommand:
		return m.Command()
	case toolsession.FieldWorkdir:
		return m.Workdir()
	case toolsession.FieldState:
		return m.State()
	case toolsession.FieldAccessMode:
		return m.AccessMode()
	case toolsession.FieldAccessSecretHash:
		return m.AccessSecretHash()
	case toolsession.FieldAccessOnceUsedAt:
		return m.AccessOnceUsedAt()
	case toolsession.FieldPinned:
		return m.Pinned()
	case toolsession.FieldLastActiveAt:
		return m.LastActiveAt()
	case toolsession.FieldDetachedAt:
		return m.DetachedAt()
	case toolsession.FieldTerminatedAt:
		return m.TerminatedAt()
	case toolsession.FieldExpiresAt:
		return m.ExpiresAt()
	case toolsession.FieldMetadataJSON:
		return m.MetadataJSON()
	case toolsession.FieldCreatedAt:
		return m.CreatedAt()
	case toolsession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolsession.FieldOwner:
		return m.OldOwner(ctx)
	case toolsession.FieldSource:
		return m.OldSource(ctx)
	case toolsession.FieldChannel:
		return m.OldChannel(ctx)
	case toolsession.FieldConversationKey:
		return m.OldConversationKey(ctx)
	case toolsession.FieldTool:
		return m.OldTool(ctx)
	case toolsession.FieldTitle:
		return m.OldTitle(ctx)
	case toolsession.FieldCommand:
		return m.OldCommand(ctx)
	case toolsession.FieldWorkdir:
		return m.OldWorkdir(ctx)
	case toolsession.FieldState:
		return m.OldState(ctx)
	case toolsession.FieldAccessMode:
		return m.OldAccessMode(ctx)
	case toolsession.FieldAccessSecretHash:
		return m.OldAccessSecretHash(ctx)
	case toolsession.FieldAccessOnceUsedAt:
		return m.OldAccessOnceUsedAt(ctx)
	case toolsession.FieldPinned:
		return m.OldPinned(ctx)
	case toolsession.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case toolsession.FieldDetachedAt:
		return m.OldDetachedAt(ctx)
	case toolsession.FieldTerminatedAt:
		return m.OldTerminatedAt(ctx)
	case toolsession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case toolsession.FieldMetadataJSON:
		return m.OldMetadataJSON(ctx)
	case toolsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case toolsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ToolSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolsession.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case toolsession.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case toolsession.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case toolsession.FieldConversationKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationKey(v)
		return nil
	case toolsession.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	case toolsession.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case toolsession.FieldCommand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case toolsession.FieldWorkdir:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkdir(v)
		return nil
	case toolsession.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case toolsession.FieldAccessMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessMode(v)
		return nil
	case toolsession.FieldAccessSecretHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessSecretHash(v)
		return nil
	case toolsession.FieldAccessOnceUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOnceUsedAt(v)
		return nil
	case toolsession.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case toolsession.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case toolsession.FieldDetachedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetachedAt(v)
		return nil
	case toolsession.FieldTerminatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminatedAt(v)
		return nil
	case toolsession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case toolsession.FieldMetadataJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataJSON(v)
		return nil
	case toolsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case toolsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ToolSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ToolSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolsession.FieldChannel) {
		fields = append(fields, toolsession.FieldChannel)
	}
	if m.FieldCleared(toolsession.FieldConversationKey) {
		fields = append(fields, toolsession.FieldConversationKey)
	}
	if m.FieldCleared(toolsession.FieldTitle) {
		fields = append(fields, toolsession.FieldTitle)
	}
	if m.FieldCleared(toolsession.FieldCommand) {
		fields = append(fields, toolsession.FieldCommand)
	}
	if m.FieldCleared(toolsession.FieldWorkdir) {
		fields = append(fields, toolsession.FieldWorkdir)
	}
	if m.FieldCleared(toolsession.FieldAccessSecretHash) {
		fields = append(fields, toolsession.FieldAccessSecretHash)
	}
	if m.FieldCleared(toolsession.FieldAccessOnceUsedAt) {
		fields = append(fields, toolsession.FieldAccessOnceUsedAt)
	}
	if m.FieldCleared(toolsession.FieldDetachedAt) {
		fields = append(fields, toolsession.FieldDetachedAt)
	}
	if m.FieldCleared(toolsession.FieldTerminatedAt) {
		fields = append(fields, toolsession.FieldTerminatedAt)
	}
	if m.FieldCleared(toolsession.FieldExpiresAt) {
		fields = append(fields, toolsession.FieldExpiresAt)
	}
	if m.FieldCleared(toolsession.FieldMetadataJSON) {
		fields = append(fields, toolsession.FieldMetadataJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolSessionMutation) ClearField(name string) error {
	switch name {
	case toolsession.FieldChannel:
		m.ClearChannel()
		return nil
	case toolsession.FieldConversationKey:
		m.ClearConversationKey()
		return nil
	case toolsession.FieldTitle:
		m.ClearTitle()
		return nil
	case toolsession.FieldCommand:
		m.ClearCommand()
		return nil
	case toolsession.FieldWorkdir:
		m.ClearWorkdir()
		return nil
	case toolsession.FieldAccessSecretHash:
		m.ClearAccessSecretHash()
		return nil
	case toolsession.FieldAccessOnceUsedAt:
		m.ClearAccessOnceUsedAt()
		return nil
	case toolsession.FieldDetachedAt:
		m.ClearDetachedAt()
		return nil
	case toolsession.FieldTerminatedAt:
		m.ClearTerminatedAt()
		return nil
	case toolsession.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case toolsession.FieldMetadataJSON:
		m.ClearMetadataJSON()
		return nil
	}
	return fmt.Errorf("unknown ToolSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolSessionMutation) ResetField(name string) error {
	switch name {
	case toolsession.FieldOwner:
		m.ResetOwner()
		return nil
	case toolsession.FieldSource:
		m.ResetSource()
		return nil
	case toolsession.FieldChannel:
		m.ResetChannel()
		return nil
	case toolsession.FieldConversationKey:
		m.ResetConversationKey()
		return nil
	case toolsession.FieldTool:
		m.ResetTool()
		return nil
	case toolsession.FieldTitle:
		m.ResetTitle()
		return nil
	case toolsession.FieldCommand:
		m.ResetCommand()
		return nil
	case toolsession.FieldWorkdir:
		m.ResetWorkdir()
		return nil
	case toolsession.FieldState:
		m.ResetState()
		return nil
	case toolsession.FieldAccessMode:
		m.ResetAccessMode()
		return nil
	case toolsession.FieldAccessSecretHash:
		m.ResetAccessSecretHash()
		return nil
	case toolsession.FieldAccessOnceUsedAt:
		m.ResetAccessOnceUsedAt()
		return nil
	case toolsession.FieldPinned:
		m.ResetPinned()
		return nil
	case toolsession.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case toolsession.FieldDetachedAt:
		m.ResetDetachedAt()
		return nil
	case toolsession.FieldTerminatedAt:
		m.ResetTerminatedAt()
		return nil
	case toolsession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case toolsession.FieldMetadataJSON:
		m.ResetMetadataJSON()
		return nil
	case toolsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case toolsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ToolSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ToolSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ToolSession edge %s", name)
}
